<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Webcam Only</title>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Segoe UI', sans-serif;
            user-select: none; /* Ch·∫∑n b√¥i ƒëen text */
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Modal Th√¥ng ƒëi·ªáp */
        #modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(15, 20, 40, 0.95);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            color: #fff;
            border: 1px solid rgba(0, 255, 136, 0.5);
            box-shadow: 0 0 60px rgba(0, 255, 136, 0.3);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 100;
            min-width: 300px;
        }

        #modal.active {
            opacity: 1; visibility: visible;
            transform: translate(-50%, -50%) scale(1);
        }

        #modal h2 { margin: 0 0 15px 0; color: #00ff88; text-transform: uppercase; letter-spacing: 2px; }
        #modal p { font-size: 1.5rem; font-weight: bold; color: #fff; line-height: 1.4; }
        #modal .hint { font-size: 0.9rem; color: #aaa; margin-top: 25px; }

        /* UI Tr·∫°ng th√°i */
        #ui-layer {
            position: absolute; top: 20px; left: 0; width: 100%;
            text-align: center; pointer-events: none; z-index: 50;
        }

        .status-badge {
            background: rgba(0, 0, 0, 0.7);
            border: 1px solid #444;
            color: #fff;
            padding: 8px 16px;
            border-radius: 30px;
            font-size: 1rem;
            display: inline-flex;
            align-items: center;
            gap: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        .gesture-icon {
            font-weight: bold;
            color: #00ff88;
            font-size: 1.2rem;
        }

        /* H∆∞·ªõng d·∫´n ph√≠m t·∫Øt */
        .guide {
            position: absolute; bottom: 20px; left: 50%;
            transform: translateX(-50%);
            color: rgba(255,255,255,0.5);
            font-size: 0.9rem;
            text-align: center;
            pointer-events: none;
            width: 100%;
        }

        /* Video Debug Nh·ªè */
        .debug-cam {
            position: absolute;
            bottom: 20px; right: 20px;
            width: 160px; height: 120px;
            border-radius: 12px;
            border: 2px solid rgba(255,255,255,0.2);
            overflow: hidden;
            z-index: 90;
            background: #000;
        }
        .input_video {
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1); /* L·∫≠t g∆∞∆°ng cho t·ª± nhi√™n */
        }

        /* M√†n h√¨nh Loading */
        #loader {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #020205;
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            z-index: 200; color: #00ff88;
        }
    </style>
</head>
<body>

    <div id="loader">
        <h2>ƒêang kh·ªüi ƒë·ªông AI...</h2>
        <p>Vui l√≤ng c·∫•p quy·ªÅn Camera</p>
    </div>

    <div id="ui-layer">
        <div class="status-badge">
            <span id="gesture-icon">‚è≥</span>
            <span id="gesture-text">ƒêang t√¨m tay...</span>
        </div>
    </div>

    <div class="guide">
        ‚òùÔ∏è <b>1 Ng√≥n:</b> Ch·ªçn &nbsp;|&nbsp; ‚úåÔ∏è <b>2 Ng√≥n:</b> Xoay &nbsp;|&nbsp; üñêÔ∏è <b>X√≤e:</b> M·ªü &nbsp;|&nbsp; ‚úä <b>N·∫Øm:</b> ƒê√≥ng
    </div>

    <!-- Video Debug (Lu√¥n hi·ªán nh·ªè ƒë·ªÉ user bi·∫øt cam c√≥ ch·∫°y ko) -->
    <div class="debug-cam">
        <video class="input_video" playsinline muted autoplay></video>
    </div>

    <canvas id="sky"></canvas>

    <div id="modal">
        <h2>Th√¥ng ƒêi·ªáp</h2>
        <p id="msg-content">...</p>
        <div class="hint">N·∫Øm tay (‚úä) ƒë·ªÉ ƒë√≥ng l·∫°i</div>
    </div>

    <!-- MediaPipe Libraries - S·ª≠ d·ª•ng phi√™n b·∫£n C·ªê ƒê·ªäNH ƒë·ªÉ tr√°nh l·ªói version mismatch -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3.1675466862/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils@0.6.1675466023/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils@0.3.1675466124/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/hands.js" crossorigin="anonymous"></script>

    <script>
        const canvas = document.getElementById('sky');
        const ctx = canvas.getContext('2d');
        const modal = document.getElementById('modal');
        const msgContent = document.getElementById('msg-content');
        const gestureText = document.getElementById('gesture-text');
        const gestureIcon = document.getElementById('gesture-icon');
        const loader = document.getElementById('loader');
        const videoElement = document.querySelector('.input_video');

        let width, height;
        let stars = [];
        let globalRotation = 0;
        let camera = null;
        let hands = null;

        // Tr·∫°ng th√°i h·ªá th·ªëng
        const state = {
            cursorX: -100,
            cursorY: -100,
            active: false,
            gesture: 'NONE', // POINTING, ROTATING, OPEN, CLOSED
            rotationSpeed: 0.0002, // T·ªëc ƒë·ªô tr√¥i m·∫∑c ƒë·ªãnh
            hoverIndex: -1
        };

        const messages = [
            "B·∫°n l√† m·ªôt ng√¥i sao s√°ng!", "T∆∞∆°ng lai n·∫±m trong tay b·∫°n.",
            "H√£y c∆∞·ªùi l√™n n√†o!", "Ki√™n tr√¨ l√† ch√¨a kh√≥a.",
            "V≈© tr·ª• ƒëang l·∫Øng nghe.", "H·∫°nh ph√∫c ·ªü ngay ƒë√¢y.",
            "M·∫°nh m·∫Ω l√™n!", "ƒêi·ªÅu k·ª≥ di·ªáu s·∫Øp ƒë·∫øn."
        ];

        // --- H·ªÜ TH·ªêNG SAO ---
        class Star {
            constructor() { this.reset(); }
            reset() {
                const r = Math.max(width, height) * (0.1 + Math.random() * 1.5);
                const theta = Math.random() * Math.PI * 2;
                this.x = r * Math.cos(theta);
                this.y = r * Math.sin(theta);
                this.size = Math.random() * 2;
                this.baseSize = this.size;
                // Sao ƒë·∫∑c bi·ªát
                this.isSpecial = Math.random() < 0.15;
                if (this.isSpecial) {
                    this.size = 5 + Math.random() * 4;
                    this.baseSize = this.size;
                    this.color = `hsl(${Math.random()*60+190}, 100%, 85%)`;
                } else {
                    this.color = `rgba(255,255,255,${Math.random()*0.6+0.2})`;
                }
                this.blinkOffset = Math.random() * 100;
            }
            getScreenPos(cx, cy, cos, sin) {
                return {
                    x: cx + (this.x * cos - this.y * sin),
                    y: cy + (this.x * sin + this.y * cos)
                };
            }
            draw(ctx, pos, frame) {
                const blink = Math.sin((frame + this.blinkOffset) * 0.05);
                const s = this.isSpecial ? this.baseSize + blink * 2 : this.baseSize + blink * 0.5;
                
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, Math.max(0, s), 0, Math.PI*2);
                
                if (this.isSpecial) {
                    ctx.shadowBlur = 15; ctx.shadowColor = this.color; ctx.fillStyle = "#fff";
                } else {
                    ctx.shadowBlur = 0; ctx.fillStyle = this.color;
                }
                ctx.fill();
            }
        }

        // --- NH·∫¨N DI·ªÜN C·ª¨ CH·ªà (CORE LOGIC) ---
        function detectGesture(landmarks) {
            const wrist = landmarks[0];
            
            // H√†m ki·ªÉm tra ng√≥n tay du·ªói
            // So s√°nh kho·∫£ng c√°ch t·ª´ ƒê·∫ßu ng√≥n tay t·ªõi C·ªï tay (Tip-Wrist)
            // v·ªõi Kh·ªõp ng√≥n tay t·ªõi C·ªï tay (PIP-Wrist)
            function isExtended(tipId, pipId) {
                const distTip = Math.hypot(landmarks[tipId].x - wrist.x, landmarks[tipId].y - wrist.y);
                const distPip = Math.hypot(landmarks[pipId].x - wrist.x, landmarks[pipId].y - wrist.y);
                return distTip > distPip; // N·∫øu ƒë·∫ßu ng√≥n xa h∆°n kh·ªõp -> Du·ªói
            }

            const idx = isExtended(8, 6);   // Ng√≥n tr·ªè
            const mid = isExtended(12, 10); // Ng√≥n gi·ªØa
            const ring = isExtended(16, 14); // Ng√≥n nh·∫´n
            const pky = isExtended(20, 18); // Ng√≥n √∫t
            
            // Ng√≥n c√°i (Logic ri√™ng): Ki·ªÉm tra ƒë·ªô m·ªü so v·ªõi kh·ªõp ng√≥n tr·ªè
            // Ho·∫∑c ƒë∆°n gi·∫£n l√† ki·ªÉm tra kho·∫£ng c√°ch ƒë·∫ßu ng√≥n c√°i t·ªõi kh·ªõp ng√≥n √∫t (n·∫øu xa l√† m·ªü)
            const thumbTip = landmarks[4];
            const pinkyKnuckle = landmarks[17];
            const thumbDist = Math.hypot(thumbTip.x - pinkyKnuckle.x, thumbTip.y - pinkyKnuckle.y);
            const thumb = thumbDist > 0.15; // Ng∆∞·ª°ng t∆∞∆°ng ƒë·ªëi

            // Thay ƒë·ªïi t·ª´ const sang let ƒë·ªÉ c√≥ th·ªÉ c·ªông th√™m ng√≥n c√°i
            let count = [idx, mid, ring, pky].filter(Boolean).length;
            if (thumb) count++; // C·ªông th√™m ng√≥n c√°i n·∫øu m·ªü (t∆∞∆°ng ƒë·ªëi)

            // LOGIC PH√ÇN LO·∫†I
            // 1. N·∫Øm tay (Closed): 0 ho·∫∑c 1 ng√≥n du·ªói
            if (count <= 1) return 'CLOSED';
            
            // 2. M·ªü tay (Open): >= 4 ng√≥n
            if (count >= 4) return 'OPEN';
            
            // 3. Hai ng√≥n (Tr·ªè + Gi·ªØa): Xoay
            // Y√™u c·∫ßu: Tr·ªè + Gi·ªØa du·ªói, Nh·∫´n + √öt g·∫≠p
            if (idx && mid && !ring && !pky) return 'ROTATING';
            
            // 4. M·ªôt ng√≥n (Tr·ªè): Ch·ªçn
            // Y√™u c·∫ßu: Tr·ªè du·ªói, Gi·ªØa g·∫≠p (quan tr·ªçng ƒë·ªÉ ko nh·∫ßm v·ªõi 2 ng√≥n)
            if (idx && !mid) return 'POINTING';

            return 'UNKNOWN'; // Tr·∫°ng th√°i l·ª° c·ª°
        }

        // --- X·ª¨ L√ù MEDIA PIPE ---
        function onResults(results) {
            loader.style.display = 'none';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const lm = results.multiHandLandmarks[0];
                const indexTip = lm[8];

                // C·∫≠p nh·∫≠t v·ªã tr√≠ con tr·ªè (L·∫≠t g∆∞∆°ng: 1 - x)
                // D√πng Linear Interpolation (Lerp) ƒë·ªÉ l√†m m∆∞·ª£t chuy·ªÉn ƒë·ªông chu·ªôt
                const targetX = (1 - indexTip.x) * width;
                const targetY = indexTip.y * height;
                
                // Lerp factor 0.3 (c√†ng nh·ªè c√†ng m∆∞·ª£t nh∆∞ng tr·ªÖ, c√†ng l·ªõn c√†ng nh·∫°y nh∆∞ng rung)
                if (state.cursorX === -100) { state.cursorX = targetX; state.cursorY = targetY; }
                else {
                    state.cursorX += (targetX - state.cursorX) * 0.4;
                    state.cursorY += (targetY - state.cursorY) * 0.4;
                }
                
                state.active = true;

                // Ph√¢n t√≠ch c·ª≠ ch·ªâ
                const gesture = detectGesture(lm);
                state.gesture = gesture;

                updateUI(gesture);
                handleLogic(gesture);

            } else {
                state.active = false;
                state.rotationSpeed = 0.0002; // Tr√¥i nh·∫π
                gestureText.innerText = "ƒêang t√¨m tay...";
                gestureIcon.innerText = "‚è≥";
                gestureText.style.color = "#aaa";
            }
        }

        function updateUI(gesture) {
            switch(gesture) {
                case 'POINTING':
                    gestureText.innerText = "M·ªòT NG√ìN: Ch·ªçn Sao";
                    gestureIcon.innerText = "‚òùÔ∏è";
                    gestureText.style.color = "#00ff88"; // Xanh
                    break;
                case 'ROTATING':
                    gestureText.innerText = "HAI NG√ìN: Xoay V≈© Tr·ª•";
                    gestureIcon.innerText = "‚úåÔ∏è";
                    gestureText.style.color = "#ff00ff"; // H·ªìng
                    break;
                case 'OPEN':
                    gestureText.innerText = "X√íE TAY: M·ªü";
                    gestureIcon.innerText = "üñêÔ∏è";
                    gestureText.style.color = "#ffff00"; // V√†ng
                    break;
                case 'CLOSED':
                    gestureText.innerText = "N·∫ÆM TAY: ƒê√≥ng";
                    gestureIcon.innerText = "‚úä";
                    gestureText.style.color = "#ff4444"; // ƒê·ªè
                    break;
                default:
                    gestureText.innerText = "H·ªá th·ªëng AI";
                    gestureIcon.innerText = "ü§ñ";
                    gestureText.style.color = "#fff";
            }
        }

        function handleLogic(gesture) {
            // 1. N·∫Øm tay -> ƒê√≥ng modal
            if (gesture === 'CLOSED') {
                closeModal();
                state.rotationSpeed = 0;
            }
            
            // 2. X√≤e tay -> M·ªü modal (n·∫øu ƒëang hover)
            else if (gesture === 'OPEN') {
                state.rotationSpeed = 0;
                if (!modal.classList.contains('active') && state.hoverIndex !== -1) {
                    openModal();
                }
            }
            
            // 3. Hai ng√≥n -> Xoay
            else if (gesture === 'ROTATING') {
                if (modal.classList.contains('active')) return; // Kh√¥ng xoay khi ƒëang ƒë·ªçc

                const cx = width / 2;
                const deadZone = 150; // V√πng an to√†n ·ªü gi·ªØa
                // T√≠nh to√°n t·ªëc ƒë·ªô d·ª±a tr√™n kho·∫£ng c√°ch t·ª´ t√¢m
                if (state.cursorX < cx - deadZone) {
                    // Tay tr√°i -> Xoay tr√°i
                    state.rotationSpeed = -0.01 * ((cx - deadZone - state.cursorX) / 400);
                } else if (state.cursorX > cx + deadZone) {
                    // Tay ph·∫£i -> Xoay ph·∫£i
                    state.rotationSpeed = 0.01 * ((state.cursorX - (cx + deadZone)) / 400);
                } else {
                    state.rotationSpeed = 0;
                }
            }
            
            // 4. M·ªôt ng√≥n -> D·ª´ng xoay ƒë·ªÉ ch·ªçn
            else if (gesture === 'POINTING') {
                state.rotationSpeed = 0; // ƒê·ª©ng y√™n ƒë·ªÉ d·ªÖ ch·ªçn
            }
        }

        // --- H√ÄM UI ---
        function openModal() {
            if (modal.classList.contains('active')) return;
            msgContent.innerText = messages[Math.floor(Math.random() * messages.length)];
            modal.classList.add('active');
            createExplosion(state.cursorX, state.cursorY);
        }

        function closeModal() {
            modal.classList.remove('active');
        }

        function createExplosion(x, y) {
            const burst = document.createElement('div');
            Object.assign(burst.style, {
                position: 'absolute', left: x + 'px', top: y + 'px',
                width: '10px', height: '10px', background: '#fff',
                borderRadius: '50%', boxShadow: '0 0 40px 15px #00ff88',
                transform: 'translate(-50%,-50%)', pointerEvents: 'none', zIndex: 200,
                transition: 'all 0.6s cubic-bezier(0,1,0.5,1)'
            });
            document.body.appendChild(burst);
            requestAnimationFrame(() => {
                burst.style.transform = 'translate(-50%,-50%) scale(6)';
                burst.style.opacity = 0;
            });
            setTimeout(() => burst.remove(), 600);
        }

        // --- KH·ªûI T·∫†O & ANIMATION ---
        function init() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            stars = [];
            for(let i=0; i<300; i++) stars.push(new Star());

            startCamera();
            animate();
        }

        async function startCamera() {
            try {
                // S·ª¨ D·ª§NG PHI√äN B·∫¢N C·ªê ƒê·ªäNH TRONG LOCATEFILE
                hands = new Hands({
                    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4.1675469240/${file}`
                });
                hands.setOptions({
                    maxNumHands: 1,
                    modelComplexity: 1, // 1: TƒÉng ƒë·ªô ch√≠nh x√°c (do ch·∫°y tr√™n PC)
                    minDetectionConfidence: 0.5,
                    minTrackingConfidence: 0.5
                });
                hands.onResults(onResults);

                camera = new Camera(videoElement, {
                    onFrame: async () => { await hands.send({image: videoElement}); },
                    width: 640, height: 480
                });
                await camera.start();
            } catch (err) {
                console.error(err);
                alert("L·ªói Camera: " + err.message);
            }
        }

        let frame = 0;
        function animate() {
            frame++;
            
            // X√≥a Background
            ctx.fillStyle = "#020205";
            ctx.fillRect(0, 0, width, height);

            // C·∫≠p nh·∫≠t g√≥c xoay
            globalRotation += state.rotationSpeed;
            const cx = width / 2;
            const cy = height / 2;
            const cos = Math.cos(globalRotation);
            const sin = Math.sin(globalRotation);

            state.hoverIndex = -1;
            let closestDist = 999;
            const hitRadius = 50; // B√°n k√≠nh b·∫Øt d√≠nh

            // V·∫Ω Sao
            for(let i=0; i<stars.length; i++) {
                const s = stars[i];
                const p = s.getScreenPos(cx, cy, cos, sin);
                s.draw(ctx, p, frame);

                // Check Hover (Ch·ªâ khi 1 ng√≥n ho·∫∑c M·ªü tay)
                if (s.isSpecial && state.active && !modal.classList.contains('active')) {
                    const dist = Math.hypot(p.x - state.cursorX, p.y - state.cursorY);
                    if (dist < hitRadius && dist < closestDist) {
                        closestDist = dist;
                        state.hoverIndex = i;
                    }
                }
            }

            // V·∫Ω Con Tr·ªè (Cursor)
            if (state.active) {
                let color = "#fff";
                let ringColor = "rgba(255,255,255,0.2)";
                
                if (state.gesture === 'POINTING') { color = "#00ff88"; ringColor = "rgba(0,255,136,0.3)"; }
                else if (state.gesture === 'ROTATING') { color = "#ff00ff"; ringColor = "rgba(255,0,255,0.3)"; }
                else if (state.gesture === 'OPEN') { color = "#ffff00"; ringColor = "rgba(255,255,0,0.3)"; }
                else if (state.gesture === 'CLOSED') { color = "#ff4444"; ringColor = "rgba(255,68,68,0.3)"; }

                // V√≤ng s√°ng con tr·ªè
                ctx.beginPath();
                ctx.arc(state.cursorX, state.cursorY, 20, 0, Math.PI*2);
                ctx.strokeStyle = color;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fillStyle = ringColor;
                ctx.fill();

                // T√¢m con tr·ªè
                ctx.beginPath();
                ctx.arc(state.cursorX, state.cursorY, 4, 0, Math.PI*2);
                ctx.fillStyle = color;
                ctx.fill();

                // Hi·ªáu ·ª©ng khi hover sao (ch·ªâ khi 1 ng√≥n ho·∫∑c m·ªü)
                if (state.hoverIndex !== -1 && (state.gesture === 'POINTING' || state.gesture === 'OPEN')) {
                    ctx.beginPath();
                    ctx.arc(state.cursorX, state.cursorY, 30, 0, Math.PI*2);
                    ctx.strokeStyle = "#fff";
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', init);
        window.onload = init;

    </script>
</body>
</html>
