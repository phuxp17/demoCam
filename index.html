<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>V≈© Tr·ª• Th√¥ng Minh (Fix Nh·∫≠n Di·ªán)</title>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none;
            user-select: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Modal Th√¥ng ƒëi·ªáp */
        #modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(15, 20, 40, 0.95);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            color: #fff;
            border: 1px solid rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.2);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 100;
            width: 80%;
            max-width: 400px;
            pointer-events: none;
        }

        #modal.active {
            opacity: 1; visibility: visible;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        #modal h2 { margin: 0 0 15px 0; color: #00ff88; text-transform: uppercase; font-size: 1.2rem; }
        #modal p { font-size: 1.4rem; font-weight: bold; color: #e0f7fa; line-height: 1.4; }
        #modal .hint { font-size: 0.9rem; color: #888; margin-top: 20px; font-weight: normal; }

        /* Overlay th√¥ng tin */
        #overlay {
            position: absolute; top: 10px; left: 0; width: 100%;
            text-align: center; pointer-events: none; z-index: 50;
        }

        .badge {
            background: rgba(0, 255, 136, 0.1); border: 1px solid #00ff88;
            color: #00ff88; padding: 5px 12px; border-radius: 20px;
            font-size: 0.9rem; display: inline-block; backdrop-filter: blur(5px);
        }

        #gesture-hint {
            margin-top: 5px; height: 20px; font-weight: bold;
            color: #00ccff; text-shadow: 0 0 5px rgba(0, 204, 255, 0.5);
        }

        /* Video Debug (M·∫∑c ƒë·ªãnh ·∫©n, hi·ªán khi b·∫•m n√∫t) */
        .debug-video-container {
            position: absolute;
            bottom: 10px; right: 10px;
            width: 160px; height: 120px;
            border: 2px solid #ff0055;
            border-radius: 10px;
            overflow: hidden;
            z-index: 90;
            display: none; /* ·∫®n m·∫∑c ƒë·ªãnh */
            background: #000;
        }
        
        /* Video g·ªëc */
        .input_video {
            width: 100%; height: 100%; object-fit: cover;
            transform: scaleX(-1); /* L·∫≠t g∆∞∆°ng */
        }

        /* N√∫t ch·ª©c nƒÉng g√≥c ph·∫£i */
        .controls {
            position: absolute; top: 10px; right: 10px;
            display: flex; gap: 10px; z-index: 60;
        }

        .btn {
            background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.3);
            color: white; padding: 8px 12px; border-radius: 8px; cursor: pointer;
            font-size: 0.8rem; backdrop-filter: blur(5px); pointer-events: auto;
        }
        .btn:hover { background: rgba(0,255,136,0.2); border-color: #00ff88; }
        .btn.active { background: #00ff88; color: #000; border-color: #00ff88; }

        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ff88; font-family: monospace; text-align: center;
        }
    </style>
</head>
<body>

    <div id="loader">ƒêang kh·ªüi ƒë·ªông h·ªá th·ªëng AI...<br><span style="font-size:0.8em; color:#666">Vui l√≤ng ch·ªù 5-10s</span></div>

    <div id="overlay">
        <div class="badge" id="device-status">ƒêang t·∫£i...</div>
        <div id="gesture-hint"></div>
        <div style="margin-top:5px; color: rgba(255,255,255,0.6); font-size: 0.75rem;" id="guide-text"></div>
    </div>

    <div class="controls">
        <button class="btn" onclick="toggleDebug()" id="btn-debug">üëÅÔ∏è Hi·ªán Camera</button>
        <button class="btn" onclick="toggleMode()">üîÑ ƒê·ªïi Ch·∫ø ƒê·ªô</button>
    </div>

    <!-- Khung video debug -->
    <div class="debug-video-container" id="debug-container">
        <video class="input_video" playsinline></video>
    </div>

    <canvas id="sky"></canvas>

    <div id="modal">
        <h2>Th√¥ng ƒêi·ªáp V≈© Tr·ª•</h2>
        <p id="msg-content">...</p>
        <div class="hint" id="modal-hint">Ch·∫°m ra ngo√†i ƒë·ªÉ ƒë√≥ng</div>
    </div>

    <!-- Scripts MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        const canvas = document.getElementById('sky');
        const ctx = canvas.getContext('2d');
        const modal = document.getElementById('modal');
        const msgContent = document.getElementById('msg-content');
        const statusBadge = document.getElementById('device-status');
        const gestureHint = document.getElementById('gesture-hint');
        const guideText = document.getElementById('guide-text');
        const modalHint = document.getElementById('modal-hint');
        const loader = document.getElementById('loader');
        const debugContainer = document.getElementById('debug-container');
        const btnDebug = document.getElementById('btn-debug');

        let width, height;
        let stars = [];
        let globalRotation = 0;
        let camera = null;
        let hands = null;
        let isDebug = false;

        // Logic Ch·∫ø ƒë·ªô
        const savedMode = localStorage.getItem('universe_mode_fix');
        let currentMode = savedMode ? savedMode : ((window.innerWidth < 1024) ? 'TOUCH' : 'WEBCAM');

        // Tr·∫°ng th√°i ƒëi·ªÅu khi·ªÉn
        const state = {
            cursorX: -100,
            cursorY: -100,
            active: false,
            rotationSpeed: 0.0005,
            hoverIndex: -1,
            gesture: 'NONE'
        };

        const messages = [
            "B·∫°n l√† duy nh·∫•t!", "C∆∞·ªùi l√™n n√†o!", "C∆° h·ªôi ƒëang ƒë·∫øn.",
            "B√¨nh y√™n nh√©.", "M·∫°nh m·∫Ω l√™n.", "V≈© tr·ª• y√™u b·∫°n.",
            "ƒê·ª´ng b·ªè cu·ªôc!", "H·∫°nh ph√∫c ·ªü ƒë√¢y."
        ];

        // --- H·ªÜ TH·ªêNG SAO ---
        class Star {
            constructor() { this.reset(); }
            reset() {
                const r = Math.max(width, height) * (0.1 + Math.random() * 1.3);
                const theta = Math.random() * Math.PI * 2;
                this.x = r * Math.cos(theta);
                this.y = r * Math.sin(theta);
                this.size = Math.random() * 2;
                this.baseSize = this.size;
                this.isSpecial = Math.random() < 0.15;
                if (this.isSpecial) {
                    this.size = (currentMode === 'TOUCH') ? 10 + Math.random()*5 : 6 + Math.random()*3;
                    this.baseSize = this.size;
                    this.color = `hsl(${Math.random()*60+190}, 100%, 80%)`;
                } else {
                    this.color = `rgba(255,255,255,${Math.random()*0.7+0.3})`;
                }
                this.blinkOffset = Math.random() * 100;
            }
            getScreenPos(cx, cy, cos, sin) {
                return {
                    x: cx + (this.x * cos - this.y * sin),
                    y: cy + (this.x * sin + this.y * cos)
                };
            }
            draw(ctx, pos, frame) {
                const blink = Math.sin((frame + this.blinkOffset) * 0.05);
                const s = this.isSpecial ? this.baseSize + blink * 2 : this.baseSize + blink * 0.5;
                ctx.beginPath();
                ctx.arc(pos.x, pos.y, Math.max(0, s), 0, Math.PI*2);
                if (this.isSpecial) {
                    ctx.fillStyle = "#fff"; ctx.shadowBlur = 15; ctx.shadowColor = this.color;
                } else {
                    ctx.fillStyle = this.color; ctx.shadowBlur = 0;
                }
                ctx.fill();
            }
        }

        function init() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            stars = [];
            const count = (currentMode === 'TOUCH') ? 150 : 350;
            for(let i=0; i<count; i++) stars.push(new Star());
            loader.style.display = 'none';
            applyMode();
        }

        function toggleMode() {
            const next = (currentMode === 'TOUCH') ? 'WEBCAM' : 'TOUCH';
            localStorage.setItem('universe_mode_fix', next);
            location.reload();
        }

        function toggleDebug() {
            isDebug = !isDebug;
            debugContainer.style.display = isDebug ? 'block' : 'none';
            btnDebug.classList.toggle('active');
            btnDebug.innerText = isDebug ? 'üëÅÔ∏è ·∫®n Camera' : 'üëÅÔ∏è Hi·ªán Camera';
        }

        function applyMode() {
            if (currentMode === 'TOUCH') setupMobileMode();
            else setupDesktopMode();
        }

        function getPointerPos(e) {
            const r = canvas.getBoundingClientRect();
            const cx = e.touches ? e.touches[0].clientX : e.clientX;
            const cy = e.touches ? e.touches[0].clientY : e.clientY;
            return { x: cx - r.left, y: cy - r.top };
        }

        // --- TOUCH MODE ---
        function setupMobileMode() {
            statusBadge.innerText = "üì± Ch·∫ø ƒë·ªô C·∫£m ·ª®ng";
            guideText.innerText = "Ch·∫°m v√†o sao ƒë·ªÉ m·ªü ‚Ä¢ K√©o ƒë·ªÉ xoay";
            modalHint.innerText = "Ch·∫°m ra ngo√†i ƒë·ªÉ ƒë√≥ng";
            gestureHint.innerText = "";
            btnDebug.style.display = 'none'; // ·∫®n n√∫t debug camera

            let startX = 0;
            canvas.addEventListener('touchstart', (e) => {
                const pos = getPointerPos(e);
                state.cursorX = pos.x; state.cursorY = pos.y;
                startX = pos.x; state.active = true;
                checkImmediateHit(pos.x, pos.y);
            }, {passive: false});
            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                const pos = getPointerPos(e);
                state.cursorX = pos.x; state.cursorY = pos.y;
                state.rotationSpeed = (pos.x - startX) * 0.0001;
            }, {passive: false});
            canvas.addEventListener('touchend', () => {
                state.active = false; state.rotationSpeed = 0.0005;
            });
            canvas.addEventListener('mousedown', (e) => {
                const p = getPointerPos(e); checkImmediateHit(p.x, p.y);
            });
        }

        function checkImmediateHit(x, y) {
            if (modal.classList.contains('active')) { closeModal(); return; }
            const cx = width/2, cy = height/2;
            const cos = Math.cos(globalRotation), sin = Math.sin(globalRotation);
            for(let s of stars) {
                if(!s.isSpecial) continue;
                const p = s.getScreenPos(cx, cy, cos, sin);
                if(Math.hypot(p.x - x, p.y - y) < 60) { openModal(x, y); break; }
            }
        }

        // --- WEBCAM MODE (C·∫¢I TI·∫æN) ---
        async function setupDesktopMode() {
            statusBadge.innerText = "üíª Ch·∫ø ƒë·ªô AI Camera";
            guideText.innerHTML = "‚òùÔ∏è 1 Ng√≥n: Ch·ªçn | ‚úåÔ∏è 2 Ng√≥n: Xoay | üñêÔ∏è M·ªü | ‚úä ƒê√≥ng";
            modalHint.innerText = "N·∫Øm tay l·∫°i ƒë·ªÉ ƒë√≥ng";
            const videoElement = document.querySelector('.input_video');

            // H√†m ph√¢n t√≠ch c·ª≠ ch·ªâ
            function detectGesture(lm) {
                const wrist = lm[0];
                const isExt = (t, p) => Math.hypot(lm[t].x - wrist.x, lm[t].y - wrist.y) > 
                                        Math.hypot(lm[p].x - wrist.x, lm[p].y - wrist.y);
                
                const idx = isExt(8, 5), mid = isExt(12, 9), ring = isExt(16, 13), pky = isExt(20, 17);
                const count = [idx, mid, ring, pky].filter(Boolean).length;
                
                // Th√™m ng√≥n c√°i (kho·∫£ng c√°ch ƒë·∫ßu ng√≥n c√°i t·ªõi kh·ªõp √∫t)
                const thumbTip = lm[4], pinkyKnuckle = lm[17];
                const thumbOpen = Math.hypot(thumbTip.x - pinkyKnuckle.x, thumbTip.y - pinkyKnuckle.y) > 0.15;
                if(thumbOpen) count++; // T√≠nh t∆∞∆°ng ƒë·ªëi

                if(count <= 1) return 'CLOSED';
                if(count >= 4) return 'OPEN';
                if(idx && mid && !ring && !pky) return 'TWO_FINGERS';
                if(idx && !mid && !ring && !pky) return 'POINTING';
                return 'UNKNOWN';
            }

            function onResults(results) {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const idxTip = lm[8];
                    
                    // L·∫•y t·ªça ƒë·ªô (L·∫≠t g∆∞∆°ng)
                    state.cursorX = (1 - idxTip.x) * width;
                    state.cursorY = idxTip.y * height;
                    state.active = true;

                    const gest = detectGesture(lm);
                    state.gesture = gest;

                    if (gest === 'CLOSED') {
                        gestureHint.innerText = "‚úä N·∫ÆM TAY (ƒê√ìNG)";
                        closeModal();
                        state.rotationSpeed = 0;
                    } else if (gest === 'OPEN') {
                        gestureHint.innerText = "üñêÔ∏è X√íE TAY (M·ªû)";
                        state.rotationSpeed = 0;
                        checkInteraction();
                    } else if (gest === 'TWO_FINGERS') {
                        gestureHint.innerText = "‚úåÔ∏è HAI NG√ìN (XOAY)";
                        const cx = width/2, dz = 100;
                        if (state.cursorX < cx - dz) state.rotationSpeed = -0.005 * ((cx - dz - state.cursorX)/200);
                        else if (state.cursorX > cx + dz) state.rotationSpeed = 0.005 * ((state.cursorX - (cx + dz))/200);
                        else state.rotationSpeed = 0;
                    } else {
                        gestureHint.innerText = "‚òùÔ∏è M·ªòT NG√ìN (CH·ªåN)";
                        state.rotationSpeed = 0;
                    }
                } else {
                    state.active = false;
                    state.rotationSpeed = 0.0005;
                    gestureHint.innerText = "üëÄ ƒêang t√¨m tay...";
                }
            }

            try {
                if(!hands) {
                    hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                    // C·∫§U H√åNH QUAN TR·ªåNG: Gi·∫£m ƒë·ªô t·ª± tin xu·ªëng ƒë·ªÉ d·ªÖ b·∫Øt tay h∆°n
                    hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 0, // Lite mode cho nhanh
                        minDetectionConfidence: 0.3, // D·ªÖ t√≠nh h∆°n (c≈© l√† 0.5)
                        minTrackingConfidence: 0.3
                    });
                    hands.onResults(onResults);
                }
                if(!camera) {
                    camera = new Camera(videoElement, {
                        onFrame: async () => { await hands.send({image: videoElement}); },
                        width: 640, height: 480,
                        facingMode: 'user'
                    });
                    await camera.start();
                }
            } catch (e) {
                console.error(e);
                alert("L·ªói Camera. Chuy·ªÉn v·ªÅ c·∫£m ·ª©ng.");
                localStorage.setItem('universe_mode_fix', 'TOUCH');
                location.reload();
            }
        }

        function checkInteraction() {
            if(modal.classList.contains('active')) return;
            if(state.hoverIndex !== -1) openModal();
        }
        function openModal(x, y) {
            if(modal.classList.contains('active')) return;
            msgContent.innerText = messages[Math.floor(Math.random()*messages.length)];
            modal.classList.add('active');
            createExplosion(x || state.cursorX, y || state.cursorY);
        }
        function closeModal() { modal.classList.remove('active'); }

        function createExplosion(x, y) {
            const b = document.createElement('div');
            Object.assign(b.style, {
                position:'absolute', left:x+'px', top:y+'px', width:'10px', height:'10px',
                background:'#fff', borderRadius:'50%', boxShadow:'0 0 30px 10px #00ff88',
                transform:'translate(-50%,-50%)', pointerEvents:'none', zIndex:200, transition:'all 0.5s'
            });
            document.body.appendChild(b);
            requestAnimationFrame(()=>{ b.style.transform='translate(-50%,-50%) scale(5)'; b.style.opacity=0; });
            setTimeout(()=>b.remove(), 500);
        }

        let frame = 0;
        function animate() {
            frame++;
            ctx.fillStyle = "#020205"; ctx.fillRect(0, 0, width, height);
            globalRotation += state.rotationSpeed;
            const cx = width/2, cy = height/2;
            const cos = Math.cos(globalRotation), sin = Math.sin(globalRotation);
            state.hoverIndex = -1;
            let closeDist = 999; const hitR = (currentMode === 'TOUCH') ? 60 : 40;

            for(let i=0; i<stars.length; i++) {
                const s = stars[i];
                const p = s.getScreenPos(cx, cy, cos, sin);
                s.draw(ctx, p, frame);
                if(currentMode==='WEBCAM' && s.isSpecial && state.active && !modal.classList.contains('active')) {
                    const d = Math.hypot(p.x - state.cursorX, p.y - state.cursorY);
                    if(d < hitR && d < closeDist) { closeDist = d; state.hoverIndex = i; }
                }
            }

            if(state.active) {
                let color = "#00ff88"; // Pointing
                if(state.gesture==='TWO_FINGERS') color = "#ff00ff";
                else if(state.gesture==='OPEN') color = "#ffff00";
                else if(state.gesture==='CLOSED') color = "#ff0000";
                
                ctx.beginPath();
                ctx.arc(state.cursorX, state.cursorY, hitR/2, 0, Math.PI*2);
                ctx.strokeStyle = color; ctx.fillStyle = color + "33";
                ctx.lineWidth = 3; ctx.fill(); ctx.stroke();
                
                if(state.hoverIndex!==-1) {
                    ctx.fillStyle="white"; ctx.beginPath(); ctx.arc(state.cursorX, state.cursorY, 5, 0, Math.PI*2); ctx.fill();
                }
            }
            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', init);
        window.onload = () => { init(); animate(); };
    </script>
</body>
</html>
