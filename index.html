<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>V≈© Tr·ª• Th√¥ng Minh (Hybrid)</title>
    
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #020205;
            font-family: 'Segoe UI', sans-serif;
            touch-action: none; /* Ch·∫∑n cu·ªôn trang tr√™n mobile */
            user-select: none;
        }

        canvas {
            display: block;
            width: 100vw;
            height: 100vh;
        }

        /* Giao di·ªán Modal Th√¥ng ƒëi·ªáp */
        #modal {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            background: rgba(15, 20, 40, 0.95);
            padding: 30px;
            border-radius: 20px;
            text-align: center;
            color: #fff;
            border: 1px solid rgba(0, 255, 136, 0.3);
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.2);
            opacity: 0;
            visibility: hidden;
            transition: all 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            z-index: 100;
            width: 80%;
            max-width: 400px;
            pointer-events: none;
        }

        #modal.active {
            opacity: 1; visibility: visible;
            transform: translate(-50%, -50%) scale(1);
            pointer-events: auto;
        }

        #modal h2 { margin: 0 0 15px 0; color: #00ff88; text-transform: uppercase; font-size: 1.2rem; }
        #modal p { font-size: 1.4rem; font-weight: bold; color: #e0f7fa; line-height: 1.4; }
        #modal .hint { font-size: 0.9rem; color: #888; margin-top: 20px; font-weight: normal; }

        /* M√†n h√¨nh ch·ªù / H∆∞·ªõng d·∫´n */
        #overlay {
            position: absolute;
            top: 20px; left: 0; width: 100%;
            text-align: center;
            pointer-events: none;
            z-index: 50;
        }

        .badge {
            background: rgba(0, 255, 136, 0.1);
            border: 1px solid #00ff88;
            color: #00ff88;
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.9rem;
            display: inline-block;
            backdrop-filter: blur(5px);
        }

        /* Hi·ªÉn th·ªã tr·∫°ng th√°i c·ª≠ ch·ªâ hi·ªán t·∫°i */
        #gesture-hint {
            margin-top: 8px;
            font-size: 0.9rem;
            color: #00ccff;
            text-shadow: 0 0 5px rgba(0, 204, 255, 0.5);
            height: 20px; 
            font-weight: bold;
        }

        /* N√∫t chuy·ªÉn ch·∫ø ƒë·ªô th·ªß c√¥ng */
        #mode-switch {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 60;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            backdrop-filter: blur(5px);
            pointer-events: auto;
        }
        #mode-switch:hover {
            background: rgba(0, 255, 136, 0.2);
            border-color: #00ff88;
        }

        /* Video ·∫©n cho PC */
        .input_video { display: none; }
        
        /* Hi·ªáu ·ª©ng load */
        #loader {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #00ff88; font-family: monospace;
        }
    </style>
</head>
<body>

    <div id="loader">ƒêang kh·ªüi ƒë·ªông h·ªá th·ªëng...</div>

    <div id="overlay">
        <div class="badge" id="device-status">ƒêang kh·ªüi t·∫°o...</div>
        <div id="gesture-hint"></div>
        <div style="margin-top:10px; color: rgba(255,255,255,0.6); font-size: 0.8rem;" id="guide-text"></div>
    </div>

    <!-- N√∫t chuy·ªÉn ch·∫ø ƒë·ªô -->
    <button id="mode-switch" onclick="toggleMode()">üîÑ Chuy·ªÉn Ch·∫ø ƒê·ªô</button>

    <video class="input_video" playsinline></video>
    <canvas id="sky"></canvas>

    <div id="modal">
        <h2>Th√¥ng ƒêi·ªáp V≈© Tr·ª•</h2>
        <p id="msg-content">...</p>
        <div class="hint" id="modal-hint">Ch·∫°m ra ngo√†i ƒë·ªÉ ƒë√≥ng</div>
    </div>

    <!-- Scripts MediaPipe -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- C·∫§U H√åNH & TR·∫†NG TH√ÅI ---
        const canvas = document.getElementById('sky');
        const ctx = canvas.getContext('2d');
        const modal = document.getElementById('modal');
        const msgContent = document.getElementById('msg-content');
        const statusBadge = document.getElementById('device-status');
        const gestureHint = document.getElementById('gesture-hint');
        const guideText = document.getElementById('guide-text');
        const modalHint = document.getElementById('modal-hint');
        const loader = document.getElementById('loader');
        const modeSwitchBtn = document.getElementById('mode-switch');

        let width, height;
        let stars = [];
        let globalRotation = 0;
        let camera = null;
        let hands = null;
        
        // --- LOGIC X√ÅC ƒê·ªäNH CH·∫æ ƒê·ªò ---
        const savedMode = localStorage.getItem('universe_mode');
        let currentMode = savedMode ? savedMode : ((window.innerWidth < 1024) ? 'TOUCH' : 'WEBCAM');

        // Tr·∫°ng th√°i ƒëi·ªÅu khi·ªÉn
        const state = {
            cursorX: -100,
            cursorY: -100,
            active: false, 
            rotationSpeed: 0.0005,
            hoverIndex: -1,
            gesture: 'NONE' // POINTING, TWO_FINGERS, OPEN, CLOSED
        };

        const messages = [
            "B·∫°n l√† duy nh·∫•t!", "H√£y c∆∞·ªùi l√™n n√†o.", "C∆° h·ªôi ƒëang ƒë·∫øn.",
            "B√¨nh y√™n trong t√¢m h·ªìn.", "S·ª©c m·∫°nh n·ªôi t·∫°i.", "V≈© tr·ª• y√™u th∆∞∆°ng b·∫°n.",
            "ƒê·ª´ng b·ªè cu·ªôc!", "H·∫°nh ph√∫c ·ªü ƒë√¢y."
        ];

        // --- H·ªÜ TH·ªêNG SAO ---
        class Star {
            constructor() { this.reset(); }
            
            reset() {
                const r = Math.max(width, height) * (0.1 + Math.random() * 1.3);
                const theta = Math.random() * Math.PI * 2;
                
                this.x = r * Math.cos(theta);
                this.y = r * Math.sin(theta);
                
                this.size = Math.random() * 2;
                this.baseSize = this.size;
                
                this.isSpecial = Math.random() < 0.15; 
                if (this.isSpecial) {
                    this.size = (currentMode === 'TOUCH') ? 10 + Math.random() * 5 : 6 + Math.random() * 3;
                    this.baseSize = this.size;
                    this.color = `hsl(${Math.random() * 60 + 190}, 100%, 80%)`;
                } else {
                    this.color = `rgba(255, 255, 255, ${Math.random() * 0.7 + 0.3})`;
                }
                
                this.blinkOffset = Math.random() * 100;
            }

            getScreenPos(centerX, centerY, cosRot, sinRot) {
                const rotX = this.x * cosRot - this.y * sinRot;
                const rotY = this.x * sinRot + this.y * cosRot;
                return {
                    x: centerX + rotX,
                    y: centerY + rotY
                };
            }

            draw(ctx, screenPos, frame) {
                const blink = Math.sin((frame + this.blinkOffset) * 0.05);
                const currentSize = this.isSpecial 
                    ? this.baseSize + blink * 2 
                    : this.baseSize + blink * 0.5;

                ctx.beginPath();
                ctx.arc(screenPos.x, screenPos.y, Math.max(0, currentSize), 0, Math.PI * 2);
                
                if (this.isSpecial) {
                    ctx.fillStyle = "#fff";
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = this.color;
                } else {
                    ctx.fillStyle = this.color;
                    ctx.shadowBlur = 0;
                }
                ctx.fill();
            }
        }

        // --- KH·ªûI T·∫†O ---
        function init() {
            width = window.innerWidth;
            height = window.innerHeight;
            canvas.width = width;
            canvas.height = height;
            
            const starCount = (currentMode === 'TOUCH') ? 150 : 350;
            stars = [];
            for (let i = 0; i < starCount; i++) stars.push(new Star());

            loader.style.display = 'none';
            applyMode();
        }

        // --- QU·∫¢N L√ù CH·∫æ ƒê·ªò ---
        function toggleMode() {
            const nextMode = (currentMode === 'TOUCH') ? 'WEBCAM' : 'TOUCH';
            localStorage.setItem('universe_mode', nextMode);
            location.reload();
        }
        
        function applyMode() {
            if (currentMode === 'TOUCH') {
                setupMobileMode();
            } else {
                setupDesktopMode();
            }
        }

        function getPointerPos(e) {
            const rect = canvas.getBoundingClientRect();
            const clientX = e.touches ? e.touches[0].clientX : e.clientX;
            const clientY = e.touches ? e.touches[0].clientY : e.clientY;
            return {
                x: clientX - rect.left,
                y: clientY - rect.top
            };
        }

        // --- CH·∫æ ƒê·ªò 1: TOUCH / MOBILE ---
        function setupMobileMode() {
            statusBadge.innerText = "üì± Ch·∫ø ƒë·ªô C·∫£m ·ª®ng";
            guideText.innerText = "Ch·∫°m v√†o sao ƒë·ªÉ m·ªü ‚Ä¢ K√©o ƒë·ªÉ xoay";
            modalHint.innerText = "Ch·∫°m ra ngo√†i ƒë·ªÉ ƒë√≥ng";
            modeSwitchBtn.innerText = "üîÑ Chuy·ªÉn sang Camera AI";
            gestureHint.innerText = "";

            let startX = 0;
            
            canvas.addEventListener('touchstart', (e) => {
                const pos = getPointerPos(e);
                state.cursorX = pos.x;
                state.cursorY = pos.y;
                startX = pos.x;
                state.active = true;
                checkImmediateHit(pos.x, pos.y);
            }, {passive: false});

            canvas.addEventListener('touchmove', (e) => {
                e.preventDefault(); 
                const pos = getPointerPos(e);
                state.cursorX = pos.x;
                state.cursorY = pos.y;
                const deltaX = pos.x - startX;
                state.rotationSpeed = deltaX * 0.0001; 
            }, {passive: false});

            canvas.addEventListener('touchend', () => {
                state.active = false;
                state.rotationSpeed = 0.0005;
            });
            
            canvas.addEventListener('mousedown', (e) => {
                const pos = getPointerPos(e);
                checkImmediateHit(pos.x, pos.y);
            });
        }

        function checkImmediateHit(x, y) {
            if (modal.classList.contains('active')) {
                closeModal();
                return;
            }

            const cx = width / 2;
            const cy = height / 2;
            const cosRot = Math.cos(globalRotation);
            const sinRot = Math.sin(globalRotation);
            const hitRadius = 60;

            for (let s of stars) {
                if (!s.isSpecial) continue;
                const pos = s.getScreenPos(cx, cy, cosRot, sinRot);
                const dist = Math.hypot(pos.x - x, pos.y - y);
                if (dist < hitRadius) {
                    openModal(x, y);
                    break;
                }
            }
        }

        // --- CH·∫æ ƒê·ªò 2: DESKTOP / WEBCAM (GESTURES M·ªöI) ---
        async function setupDesktopMode() {
            statusBadge.innerText = "üíª Ch·∫ø ƒë·ªô AI Camera";
            guideText.innerHTML = "‚òùÔ∏è <b>1 Ng√≥n:</b> Ch·ªçn &nbsp;|&nbsp; ‚úåÔ∏è <b>2 Ng√≥n:</b> Xoay &nbsp;|&nbsp; üñêÔ∏è <b>M·ªü:</b> Xem &nbsp;|&nbsp; ‚úä <b>N·∫Øm:</b> ƒê√≥ng";
            modalHint.innerText = "N·∫Øm tay l·∫°i ƒë·ªÉ ƒë√≥ng";
            modeSwitchBtn.innerText = "üîÑ Chuy·ªÉn sang C·∫£m ·ª©ng";

            const videoElement = document.querySelector('.input_video');
            
            function detectGesture(lm) {
                const wrist = lm[0];
                // C√°c ƒë·∫ßu ng√≥n tay: 8(Tr·ªè), 12(Gi·ªØa), 16(Nh·∫´n), 20(√öt)
                // C√°c kh·ªõp d∆∞·ªõi: 5, 9, 13, 17
                
                // H√†m ki·ªÉm tra ng√≥n tay c√≥ du·ªói kh√¥ng (so kho·∫£ng c√°ch t·ªõi c·ªï tay)
                const isExtended = (tipIdx, pipIdx) => {
                    const dTip = Math.hypot(lm[tipIdx].x - wrist.x, lm[tipIdx].y - wrist.y);
                    const dPip = Math.hypot(lm[pipIdx].x - wrist.x, lm[pipIdx].y - wrist.y);
                    return dTip > dPip; // ƒê·∫ßu ng√≥n xa c·ªï tay h∆°n kh·ªõp -> Du·ªói
                };

                const indexExt = isExtended(8, 5);
                const middleExt = isExtended(12, 9);
                const ringExt = isExtended(16, 13);
                const pinkyExt = isExtended(20, 17);
                const thumbExt = isExtended(4, 2); // Ng√≥n c√°i t∆∞∆°ng ƒë·ªëi

                const extCount = [indexExt, middleExt, ringExt, pinkyExt].filter(Boolean).length;
                if (thumbExt) extCount++;

                // 1. N·∫Øm tay (Closed): 0 ho·∫∑c 1 ng√≥n du·ªói (th∆∞·ªùng ng√≥n c√°i hay b·ªã sai)
                if (extCount <= 1) return 'CLOSED';
                
                // 2. M·ªü tay (Open): 4 ho·∫∑c 5 ng√≥n du·ªói
                if (extCount >= 4) return 'OPEN';
                
                // 3. Hai ng√≥n (Victory): Tr·ªè & Gi·ªØa du·ªói, Nh·∫´n & √öt g·∫≠p
                if (indexExt && middleExt && !ringExt && !pinkyExt) return 'TWO_FINGERS';
                
                // 4. M·ªôt ng√≥n (Pointing): Tr·ªè du·ªói, c√°c ng√≥n kh√°c g·∫≠p
                if (indexExt && !middleExt && !ringExt && !pinkyExt) return 'POINTING';

                return 'UNKNOWN';
            }

            function onResults(results) {
                if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                    const lm = results.multiHandLandmarks[0];
                    const indexTip = lm[8];

                    // Map t·ªça ƒë·ªô 0-1 sang width-height (L·∫≠t g∆∞∆°ng)
                    state.cursorX = (1 - indexTip.x) * width;
                    state.cursorY = indexTip.y * height;
                    state.active = true;

                    // Nh·∫≠n di·ªán c·ª≠ ch·ªâ
                    const gesture = detectGesture(lm);
                    state.gesture = gesture;

                    // X·ª≠ l√Ω Logic d·ª±a tr√™n c·ª≠ ch·ªâ
                    if (gesture === 'CLOSED') {
                        gestureHint.innerText = "‚úä N·∫ÆM TAY (ƒê√ìNG)";
                        closeModal();
                        state.rotationSpeed = 0; // D·ª´ng xoay
                    } 
                    else if (gesture === 'OPEN') {
                        gestureHint.innerText = "üñêÔ∏è X√íE TAY (M·ªû)";
                        state.rotationSpeed = 0;
                        checkInteraction(false); // Hover ƒë·ªÉ m·ªü
                    } 
                    else if (gesture === 'TWO_FINGERS') {
                        gestureHint.innerText = "‚úåÔ∏è HAI NG√ìN (XOAY)";
                        // Logic Xoay: D·ª±a tr√™n v·ªã tr√≠ tay so v·ªõi t√¢m
                        const cx = width / 2;
                        const deadZone = 100;
                        if (state.cursorX < cx - deadZone) {
                            state.rotationSpeed = -0.005 * ((cx - deadZone - state.cursorX) / 200);
                        } else if (state.cursorX > cx + deadZone) {
                            state.rotationSpeed = 0.005 * ((state.cursorX - (cx + deadZone)) / 200);
                        } else {
                            state.rotationSpeed = 0;
                        }
                    } 
                    else {
                        // POINTING ho·∫∑c UNKNOWN
                        gestureHint.innerText = "‚òùÔ∏è M·ªòT NG√ìN (CH·ªåN)";
                        state.rotationSpeed = 0; // Ch·ªâ di chuy·ªÉn con tr·ªè, kh√¥ng xoay
                    }

                } else {
                    state.active = false;
                    state.rotationSpeed = 0.0005; // Tr√¥i t·ª± nhi√™n
                    gestureHint.innerText = "üëÄ ƒêang t√¨m tay...";
                }
            }

            try {
                if (!hands) {
                    hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
                    hands.setOptions({
                        maxNumHands: 1,
                        modelComplexity: 1,
                        minDetectionConfidence: 0.6, // TƒÉng ƒë·ªô tin c·∫≠y ƒë·ªÉ nh·∫≠n di·ªán c·ª≠ ch·ªâ t·ªët h∆°n
                        minTrackingConfidence: 0.6
                    });
                    hands.onResults(onResults);
                }

                if (!camera) {
                    camera = new Camera(videoElement, {
                        onFrame: async () => { await hands.send({image: videoElement}); },
                        width: 640, height: 480
                    });
                    await camera.start();
                }
            } catch (e) {
                console.error(e);
                alert("Kh√¥ng th·ªÉ m·ªü Camera. ƒêang chuy·ªÉn v·ªÅ ch·∫ø ƒë·ªô C·∫£m ·ª©ng.");
                localStorage.setItem('universe_mode', 'TOUCH');
                location.reload();
            }
        }

        // --- H√ÄM UI CHUNG ---
        function checkInteraction(isClickEvent) {
            if (modal.classList.contains('active')) {
                if (isClickEvent && currentMode === 'TOUCH') closeModal();
                return;
            }
            if (state.hoverIndex !== -1) {
                openModal();
            }
        }

        function openModal(x, y) {
            if (modal.classList.contains('active')) return;
            msgContent.innerText = messages[Math.floor(Math.random() * messages.length)];
            modal.classList.add('active');
            createExplosion(x || state.cursorX, y || state.cursorY);
        }

        function closeModal() {
            modal.classList.remove('active');
        }

        function createExplosion(x, y) {
            const burst = document.createElement('div');
            Object.assign(burst.style, {
                position: 'absolute', left: x + 'px', top: y + 'px',
                width: '10px', height: '10px', background: '#fff',
                borderRadius: '50%', boxShadow: '0 0 30px 10px #00ff88',
                transform: 'translate(-50%,-50%)', pointerEvents: 'none', zIndex: 200,
                transition: 'all 0.5s ease-out'
            });
            document.body.appendChild(burst);
            requestAnimationFrame(() => {
                burst.style.transform = 'translate(-50%,-50%) scale(5)';
                burst.style.opacity = 0;
            });
            setTimeout(() => burst.remove(), 500);
        }

        // --- RENDER LOOP ---
        let frame = 0;
        function animate() {
            frame++;
            ctx.fillStyle = "#020205";
            ctx.fillRect(0, 0, width, height);

            globalRotation += state.rotationSpeed;
            const cx = width / 2;
            const cy = height / 2;
            const cosRot = Math.cos(globalRotation);
            const sinRot = Math.sin(globalRotation);

            state.hoverIndex = -1;
            let closestDist = 999;
            const hitRadius = (currentMode === 'TOUCH') ? 60 : 40;

            for (let i = 0; i < stars.length; i++) {
                const s = stars[i];
                const screenPos = s.getScreenPos(cx, cy, cosRot, sinRot);
                
                s.draw(ctx, screenPos, frame);

                if (currentMode === 'WEBCAM' && s.isSpecial && state.active && !modal.classList.contains('active')) {
                    const dist = Math.hypot(screenPos.x - state.cursorX, screenPos.y - state.cursorY);
                    if (dist < hitRadius && dist < closestDist) {
                        closestDist = dist;
                        state.hoverIndex = i;
                    }
                }
            }

            // V·∫Ω con tr·ªè
            if (state.active) {
                // Style con tr·ªè d·ª±a tr√™n c·ª≠ ch·ªâ
                if (state.gesture === 'TWO_FINGERS') {
                    ctx.strokeStyle = "#ff00ff"; // M√†u h·ªìng cho ch·∫ø ƒë·ªô Xoay
                    ctx.fillStyle = "rgba(255, 0, 255, 0.2)";
                } else if (state.gesture === 'OPEN') {
                    ctx.strokeStyle = "#ffff00"; // M√†u v√†ng cho ch·∫ø ƒë·ªô M·ªü
                    ctx.fillStyle = "rgba(255, 255, 0, 0.2)";
                } else if (state.gesture === 'CLOSED') {
                    ctx.strokeStyle = "#ff0000"; // M√†u ƒë·ªè cho ch·∫ø ƒë·ªô ƒê√≥ng
                    ctx.fillStyle = "rgba(255, 0, 0, 0.2)";
                } else {
                    ctx.strokeStyle = "#00ff88"; // M√†u xanh cho ch·∫ø ƒë·ªô Ch·ªçn
                    ctx.fillStyle = "rgba(0, 255, 136, 0.2)";
                }

                ctx.beginPath();
                ctx.arc(state.cursorX, state.cursorY, hitRadius / 2, 0, Math.PI * 2);
                ctx.lineWidth = 3;
                ctx.stroke();
                ctx.fill();

                if (state.hoverIndex !== -1 && state.gesture === 'OPEN') {
                    // Logic m·ªü ƒë√£ x·ª≠ l√Ω trong onResults
                } else if (state.hoverIndex !== -1) {
                     // Highlight khi hover
                     ctx.fillStyle = "white";
                     ctx.beginPath();
                     ctx.arc(state.cursorX, state.cursorY, 5, 0, Math.PI*2);
                     ctx.fill();
                }
            }

            requestAnimationFrame(animate);
        }

        window.addEventListener('resize', init);
        window.onload = () => {
            init();
            animate();
        };

    </script>
</body>
</html>
